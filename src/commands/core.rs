//! Core task management commands
//!
//! This module contains the fundamental task operations like init, show,
//! complete, add, remove, edit, reset, list, and view.

use super::{dependencies, utils, CommandResult};
use crate::{
    cli::CliPriority,
    model::{Phase, Priority, Task, TaskStatus},
    parser, state, ui,
};
use regex;
use std::fs;
use std::path::{Path, PathBuf};

/// Initialize a new project from a Markdown file
pub fn init_project(filepath: &PathBuf) -> CommandResult {
    // Read and parse the markdown file
    let markdown_content = fs::read_to_string(filepath)?;
    let project_name = filepath
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("Untitled Project");
    let mut roadmap =
        parser::parse_markdown_to_roadmap(&markdown_content, Some(filepath), project_name)?;

    // Set up local project directory structure
    setup_local_project_directory(&mut roadmap, filepath)?;

    // Save the state
    state::save_state(&roadmap)?;

    // Display enhanced success message with project structure info
    ui::display_init_success(&roadmap);
    display_project_structure_info();

    Ok(())
}

/// Set up the local .rask project directory with comprehensive project files
fn setup_local_project_directory(
    roadmap: &mut crate::model::Roadmap,
    source_file: &PathBuf,
) -> CommandResult {
    use std::path::Path;

    // Create .rask directory structure
    let rask_dir = Path::new(".rask");
    if !rask_dir.exists() {
        fs::create_dir_all(&rask_dir)?;
    }

    // Create subdirectories for organization
    let subdirs = ["state", "exports", "cache", "templates", "ai"];
    for subdir in &subdirs {
        let dir_path = rask_dir.join(subdir);
        if !dir_path.exists() {
            fs::create_dir_all(&dir_path)?;
        }
    }

    // 1. Create a human-readable project overview
    create_project_overview(roadmap, rask_dir)?;

    // 2. Create editable task details file
    create_task_details_file(roadmap, rask_dir)?;

    // 3. Create project configuration
    create_project_config(roadmap, rask_dir, source_file)?;

    // 4. Create a README explaining the structure
    create_rask_readme(rask_dir)?;

    // 5. Create a live sync watcher script (future enhancement)
    create_sync_tools(rask_dir)?;

    Ok(())
}

/// Create a human-readable project overview file
fn create_project_overview(roadmap: &crate::model::Roadmap, rask_dir: &Path) -> CommandResult {
    let overview_content = format!(
        r#"# Project Overview: {}

## üìä Quick Stats
- Total Tasks: {}
- Completed: {}
- Pending: {}
- Progress: {:.1}%

## üìã Task Summary by Phase
{}

## üè∑Ô∏è Tags Used
{}

## üîó Dependencies Overview
{}

---
*This file is auto-generated by Rask. It provides a quick overview of your project state.*
*Edit your main roadmap.md or use Rask commands to make changes.*
"#,
        roadmap.title,
        roadmap.tasks.len(),
        roadmap
            .tasks
            .iter()
            .filter(|t| t.status == crate::model::TaskStatus::Completed)
            .count(),
        roadmap
            .tasks
            .iter()
            .filter(|t| t.status == crate::model::TaskStatus::Pending)
            .count(),
        if roadmap.tasks.is_empty() {
            0.0
        } else {
            (roadmap
                .tasks
                .iter()
                .filter(|t| t.status == crate::model::TaskStatus::Completed)
                .count() as f64
                / roadmap.tasks.len() as f64)
                * 100.0
        },
        generate_phase_summary(roadmap),
        generate_tags_summary(roadmap),
        generate_dependencies_summary(roadmap)
    );

    fs::write(rask_dir.join("project-overview.md"), overview_content)?;
    Ok(())
}

/// Create an editable task details file with metadata
fn create_task_details_file(roadmap: &crate::model::Roadmap, rask_dir: &Path) -> CommandResult {
    let mut details_content = String::from(
        r#"# Task Details & Metadata

This file contains detailed information about each task. You can edit priorities, tags,
notes, and time estimates here. Run `rask sync` to apply changes back to the project.

---

"#,
    );

    for task in &roadmap.tasks {
        let status_str = if task.status == crate::model::TaskStatus::Completed {
            "‚úÖ Completed"
        } else {
            "‚è≥ Pending"
        };

        let tags_str = if task.tags.is_empty() {
            "None".to_string()
        } else {
            let tags_vec: Vec<String> = task.tags.iter().cloned().collect();
            tags_vec.join(", ")
        };

        let estimated_hours_str = task
            .estimated_hours
            .map(|h| h.to_string())
            .unwrap_or_else(|| "Not set".to_string());

        let dependencies_str = if task.dependencies.is_empty() {
            "None".to_string()
        } else {
            task.dependencies
                .iter()
                .map(|d| d.to_string())
                .collect::<Vec<_>>()
                .join(", ")
        };

        let implementation_notes_str = if task.implementation_notes.is_empty() {
            "No implementation notes".to_string()
        } else {
            task.implementation_notes
                .iter()
                .enumerate()
                .map(|(i, note)| format!("{}. {}", i + 1, note))
                .collect::<Vec<_>>()
                .join("\n")
        };

        details_content.push_str(&format!(
            r#"## Task #{}: {}

**Status**: {}
**Priority**: {}
**Phase**: {}
**Tags**: {}
**Estimated Hours**: {}
**Dependencies**: {}

**Notes**:
{}

**Implementation Notes**:
{}

---

"#,
            task.id,
            task.description,
            status_str,
            task.priority.to_string(),
            task.phase.name,
            tags_str,
            estimated_hours_str,
            dependencies_str,
            task.notes.as_deref().unwrap_or("No notes"),
            implementation_notes_str
        ));
    }

    fs::write(rask_dir.join("task-details.md"), details_content)?;
    Ok(())
}

/// Create project configuration file
fn create_project_config(
    roadmap: &crate::model::Roadmap,
    rask_dir: &Path,
    source_file: &Path,
) -> CommandResult {
    let config_content = format!(
        r#"# Rask Project Configuration

[project]
name = "{}"
source_file = "{}"
created_at = "{}"
version = "3.3.0"

[sync]
auto_sync = true
watch_roadmap = true
backup_on_sync = true

[ai]
enabled = true
auto_suggestions = false
context_aware = true

[export]
default_format = "html"
include_metadata = true
export_dir = ".rask/exports"

[display]
default_view = "grouped_by_phase"
show_dependencies = true
show_time_estimates = true
"#,
        roadmap.title,
        source_file.display(),
        chrono::Utc::now().to_rfc3339()
    );

    fs::write(rask_dir.join("config.toml"), config_content)?;
    Ok(())
}

/// Create a comprehensive README for the .rask directory
fn create_rask_readme(rask_dir: &Path) -> CommandResult {
    let readme_content = r#"# Rask Project Directory

This directory contains all the behind-the-scenes files that Rask uses to manage your project.
Everything here is designed to be human-readable and editable!

## üìÅ Directory Structure

```
.rask/
‚îú‚îÄ‚îÄ project-overview.md     # üìä Quick project stats and summary
‚îú‚îÄ‚îÄ task-details.md         # üìù Detailed task metadata (editable!)
‚îú‚îÄ‚îÄ config.toml            # ‚öôÔ∏è  Project configuration
‚îú‚îÄ‚îÄ README.md              # üìñ This file
‚îú‚îÄ‚îÄ state/                 # üíæ Internal state files
‚îú‚îÄ‚îÄ exports/               # üì§ Generated reports and exports
‚îú‚îÄ‚îÄ cache/                 # üóÑÔ∏è  Temporary files and cache
‚îú‚îÄ‚îÄ templates/             # üìã Custom task templates
‚îî‚îÄ‚îÄ ai/                    # ü§ñ AI conversation history and context
```

## üîÑ Workflow Integration

### Quick Navigation
- **View project status**: Open `project-overview.md`
- **Edit task details**: Open `task-details.md`
- **Configure project**: Edit `config.toml`
- **Check exports**: Browse `exports/` directory

### Making Changes
1. **Via your IDE**: Edit `task-details.md` or main roadmap
2. **Via Rask commands**: Use `rask add`, `rask edit`, etc.
3. **Sync changes**: Run `rask sync` to reconcile differences

### Fast Commands
```bash
# Quick project overview
rask show --group-by-phase

# Edit in your preferred editor
$EDITOR .rask/task-details.md

# Sync any manual changes
rask sync

# Generate fresh exports
rask export html -o .rask/exports/current.html
```

## üí° Pro Tips

1. **IDE Integration**: Add `.rask/project-overview.md` to your IDE's sidebar for quick reference
2. **Version Control**: Add `.rask/cache/` to your `.gitignore` but commit the rest
3. **Team Sharing**: Share `.rask/config.toml` and templates with your team
4. **Quick Edits**: Edit `task-details.md` for bulk metadata changes, then `rask sync`

---
*Generated by Rask v3.3.0 - AI-Powered Project Management*
"#;

    fs::write(rask_dir.join("README.md"), readme_content)?;
    Ok(())
}

/// Create sync and workflow tools
fn create_sync_tools(rask_dir: &Path) -> CommandResult {
    // Create a simple sync script for future enhancement
    let sync_script = r#"#!/bin/bash
# Rask Sync Helper Script
# This script helps synchronize changes between your roadmap and Rask state

echo "üîÑ Syncing Rask project..."

# Check if main roadmap file has been modified
if [ roadmap.md -nt .rask/state/last_sync ]; then
    echo "üìù Roadmap.md has changes, updating Rask state..."
    rask sync --from-roadmap
fi

# Check if task details have been modified
if [ .rask/task-details.md -nt .rask/state/last_sync ]; then
    echo "üìä Task details have changes, updating Rask state..."
    rask sync --from-details
fi

# Update sync timestamp
touch .rask/state/last_sync

echo "‚úÖ Sync complete!"
"#;

    let script_path = rask_dir.join("sync.sh");
    fs::write(&script_path, sync_script)?;

    // Make it executable on Unix systems
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&script_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&script_path, perms)?;
    }

    Ok(())
}

// Helper functions for generating summaries
fn generate_phase_summary(roadmap: &crate::model::Roadmap) -> String {
    use std::collections::HashMap;
    let mut phase_counts = HashMap::new();

    for task in &roadmap.tasks {
        let phase_name = &task.phase.name;
        let entry = phase_counts.entry(phase_name.clone()).or_insert((0, 0));
        if task.status == crate::model::TaskStatus::Completed {
            entry.1 += 1;
        } else {
            entry.0 += 1;
        }
    }

    let mut summary = String::new();
    for (phase, (pending, completed)) in phase_counts {
        summary.push_str(&format!(
            "- **{}**: {} pending, {} completed\n",
            phase, pending, completed
        ));
    }

    if summary.is_empty() {
        "No phases found".to_string()
    } else {
        summary
    }
}

fn generate_tags_summary(roadmap: &crate::model::Roadmap) -> String {
    use std::collections::HashMap;
    let mut tag_counts = HashMap::new();

    for task in &roadmap.tasks {
        for tag in &task.tags {
            *tag_counts.entry(tag.clone()).or_insert(0) += 1;
        }
    }

    if tag_counts.is_empty() {
        "No tags used".to_string()
    } else {
        let mut tags: Vec<_> = tag_counts.into_iter().collect();
        tags.sort_by(|a, b| b.1.cmp(&a.1));
        tags.into_iter()
            .map(|(tag, count)| format!("- **{}** ({})", tag, count))
            .collect::<Vec<_>>()
            .join("\n")
    }
}

fn generate_dependencies_summary(roadmap: &crate::model::Roadmap) -> String {
    let total_deps: usize = roadmap.tasks.iter().map(|t| t.dependencies.len()).sum();
    if total_deps == 0 {
        "No task dependencies".to_string()
    } else {
        format!(
            "- Total dependency relationships: {}\n- Tasks with dependencies: {}",
            total_deps,
            roadmap
                .tasks
                .iter()
                .filter(|t| !t.dependencies.is_empty())
                .count()
        )
    }
}

/// Display information about the created project structure
fn display_project_structure_info() {
    use crate::ui;

    ui::display_info("üìÅ Local project directory created at .rask/");
    println!("   üìä project-overview.md  - Quick stats and summary");
    println!("   üìù task-details.md      - Editable task metadata");
    println!("   ‚öôÔ∏è  config.toml          - Project configuration");
    println!("   üìñ README.md           - Directory documentation");
    println!();
    ui::display_info("üí° Quick workflow tips:");
    println!("   ‚Ä¢ Open .rask/project-overview.md for quick project status");
    println!("   ‚Ä¢ Edit .rask/task-details.md to bulk-update task metadata");
    println!("   ‚Ä¢ Use 'rask sync' to apply manual changes back to project");
    println!("   ‚Ä¢ Add .rask/ to your IDE sidebar for easy access");
}

/// Show the current project status with enhanced display
pub fn show_project() -> CommandResult {
    let roadmap = state::load_state()?;
    ui::display_roadmap_enhanced(&roadmap, true); // Show detailed view with tags, priorities, and notes
    Ok(())
}

/// Show the current project status with enhanced phase-based display options
pub fn show_project_enhanced(
    group_by_phase: bool,
    phase_filter: Option<&str>,
    detailed: bool,
    collapse_completed: bool,
) -> CommandResult {
    let roadmap = state::load_state()?;

    if group_by_phase {
        ui::display_roadmap_grouped_by_phase(&roadmap, detailed, collapse_completed);
    } else if let Some(phase) = phase_filter {
        ui::display_roadmap_filtered_by_phase(&roadmap, phase, detailed);
    } else {
        ui::display_roadmap_enhanced(&roadmap, detailed);
    }

    Ok(())
}

/// Show project timeline with phase-based horizontal layout
pub fn show_timeline(
    detailed: bool,
    active_only: bool,
    compact: bool,
    page: Option<usize>,
    page_size: Option<usize>,
) -> CommandResult {
    let roadmap = state::load_state()?;
    ui::display_project_timeline(&roadmap, detailed, active_only, compact, page, page_size);
    Ok(())
}

/// Mark a task as completed
pub fn complete_task(task_id: usize) -> CommandResult {
    // Load current state
    let mut roadmap = state::load_state()?;

    // Validate dependencies first
    if let Err(errors) = roadmap.validate_task_dependencies(task_id) {
        for error in &errors {
            ui::display_error(&format!("Dependency validation failed: {}", error));
        }
        return Err("Cannot complete task due to dependency issues".into());
    }

    // Check dependencies before completing
    if let Some(task) = roadmap.find_task_by_id(task_id) {
        let completed_task_ids = roadmap.get_completed_task_ids();
        if !task.can_be_started(&completed_task_ids) {
            let incomplete_deps: Vec<usize> = task
                .dependencies
                .iter()
                .filter(|&&dep_id| !completed_task_ids.contains(&dep_id))
                .copied()
                .collect();

            // Show detailed dependency information
            ui::display_dependency_error(task_id, &incomplete_deps, &roadmap);
            return Err(format!(
                "Cannot complete task {}. Missing dependencies: {:?}",
                task_id, incomplete_deps
            )
            .into());
        }
    }

    // Find tasks that will be unblocked (before completing this task)
    let newly_unblocked = dependencies::find_newly_unblocked_tasks(&roadmap, task_id);

    // Find and update the task
    let task = roadmap.tasks.iter_mut().find(|t| t.id == task_id);

    match task {
        Some(task) => {
            let task_description = task.description.clone();
            task.mark_completed();

            // Save to both JSON state and original markdown file
            utils::save_and_sync(&roadmap)?;

            // Display enhanced completion success with dependency unlocking
            ui::display_completion_success_enhanced(
                task_id,
                &task_description,
                &newly_unblocked,
                &roadmap,
            );
            ui::display_roadmap(&roadmap);

            Ok(())
        }
        None => Err(format!("Task with ID {} not found.", task_id).into()),
    }
}

/// Add a new task with enhanced metadata support
pub fn add_task_enhanced(
    description: &str,
    tags: &Option<String>,
    priority: &Option<CliPriority>,
    phase: &Option<String>,
    notes: &Option<String>,
    dependencies: &Option<String>,
    estimated_hours: &Option<f64>,
) -> CommandResult {
    // Enhanced input validation
    if let Err(validation_error) = utils::validate_task_description(description) {
        ui::display_error(&format!("Invalid task description: {}", validation_error));
        ui::display_info("üí° Try providing a more descriptive task name");
        return Err(validation_error.into());
    }

    // Load current state
    let mut roadmap = state::load_state()?;

    // Parse tags with validation
    let parsed_tags: Vec<String> = if let Some(tag_str) = tags {
        utils::validate_and_parse_tags(tag_str)?
    } else {
        Vec::new()
    };

    // Parse dependencies with enhanced validation
    let parsed_deps: Vec<usize> = if let Some(dep_str) = dependencies {
        utils::validate_and_parse_dependencies(dep_str, &roadmap)?
    } else {
        Vec::new()
    };

    // Create a temporary task to check for circular dependencies
    if !parsed_deps.is_empty() {
        let temp_task = Task::new(roadmap.get_next_task_id(), description.to_string())
            .with_dependencies(parsed_deps.clone());
        let mut temp_roadmap = roadmap.clone();
        temp_roadmap.tasks.push(temp_task);

        // Check for circular dependencies
        if let Err(errors) =
            temp_roadmap.validate_task_dependencies(temp_roadmap.get_next_task_id() - 1)
        {
            for error in &errors {
                ui::display_error(&format!("Dependency validation failed: {}", error));
            }
            return Err("Cannot add task due to dependency conflicts".into());
        }
    }

    // Create new task with enhanced features
    let mut new_task = Task::new(roadmap.get_next_task_id(), description.to_string());

    if !parsed_tags.is_empty() {
        new_task = new_task.with_tags(parsed_tags);
    }

    if let Some(ref priority_cli) = priority {
        let priority_model: Priority = priority_cli.clone().into();
        new_task = new_task.with_priority(priority_model);
    }

    if let Some(ref phase_str) = phase {
        let phase_model = Phase::from_string(phase_str);
        new_task = new_task.with_phase(phase_model);
    }

    if let Some(ref note_text) = notes {
        if note_text.trim().is_empty() {
            ui::display_warning("Empty note provided - skipping");
        } else if note_text.len() > 1000 {
            return Err("Note cannot exceed 1000 characters".into());
        } else {
            new_task = new_task.with_notes(note_text.clone());
        }
    }

    if !parsed_deps.is_empty() {
        new_task = new_task.with_dependencies(parsed_deps);
    }

    // Set estimated hours if provided
    if let Some(hours) = estimated_hours {
        if *hours <= 0.0 {
            return Err("Estimated hours must be greater than 0".into());
        }
        if *hours > 1000.0 {
            return Err("Estimated hours cannot exceed 1000 hours".into());
        }
        new_task.set_estimated_hours(*hours);
    }

    // Add task to roadmap
    roadmap.add_task(new_task.clone());

    // Save to both JSON state and original markdown file
    utils::save_and_sync(&roadmap)?;

    // Display success and updated roadmap
    ui::display_add_success_enhanced(&new_task);
    ui::display_roadmap(&roadmap);

    Ok(())
}

/// Remove a task from the project
pub fn remove_task(task_id: usize) -> CommandResult {
    // Load current state
    let mut roadmap = state::load_state()?;

    // Check if any other tasks depend on this one
    let dependents: Vec<usize> = roadmap
        .tasks
        .iter()
        .filter(|t| t.dependencies.contains(&task_id))
        .map(|t| t.id)
        .collect();

    if !dependents.is_empty() {
        return Err(format!(
            "Cannot remove task {}. Other tasks depend on it: {:?}",
            task_id, dependents
        )
        .into());
    }

    // Remove the task
    if let Some(removed_task) = roadmap.remove_task(task_id) {
        // Save to both JSON state and original markdown file
        utils::save_and_sync(&roadmap)?;

        // Display success and updated roadmap
        ui::display_remove_success(&removed_task.description);
        ui::display_roadmap(&roadmap);

        Ok(())
    } else {
        Err(format!("Task with ID {} not found.", task_id).into())
    }
}

/// Edit the description of an existing task
pub fn edit_task(task_id: usize, new_description: &str) -> CommandResult {
    // Load current state
    let mut roadmap = state::load_state()?;

    // Find and update the task
    let task = roadmap.tasks.iter_mut().find(|t| t.id == task_id);

    match task {
        Some(task) => {
            let old_description = task.description.clone();
            task.description = new_description.to_string();

            // Save to both JSON state and original markdown file
            utils::save_and_sync(&roadmap)?;

            // Display success and updated roadmap
            ui::display_edit_success(task_id, &old_description, new_description);
            ui::display_roadmap(&roadmap);

            Ok(())
        }
        None => Err(format!("Task with ID {} not found.", task_id).into()),
    }
}

/// Reset task(s) to pending status
pub fn reset_tasks(task_id: Option<usize>) -> CommandResult {
    // Load current state
    let mut roadmap = state::load_state()?;

    match task_id {
        Some(id) => {
            // Reset specific task
            let task = roadmap.tasks.iter_mut().find(|t| t.id == id);

            match task {
                Some(task) => {
                    if task.status == TaskStatus::Completed {
                        task.mark_pending();

                        // Save to both JSON state and original markdown file
                        utils::save_and_sync(&roadmap)?;

                        // Display success and updated roadmap
                        ui::display_reset_success(Some(id));
                        ui::display_roadmap(&roadmap);
                    } else {
                        ui::display_info(&format!("Task {} is already pending.", id));
                    }

                    Ok(())
                }
                None => Err(format!("Task with ID {} not found.", id).into()),
            }
        }
        None => {
            // Reset all tasks
            let completed_count = roadmap
                .tasks
                .iter()
                .filter(|t| t.status == TaskStatus::Completed)
                .count();

            if completed_count > 0 {
                for task in &mut roadmap.tasks {
                    task.mark_pending();
                }

                // Save to both JSON state and original markdown file
                utils::save_and_sync(&roadmap)?;

                // Display success and updated roadmap
                ui::display_reset_success(None);
                ui::display_roadmap(&roadmap);
            } else {
                ui::display_info("All tasks are already pending.");
            }

            Ok(())
        }
    }
}

/// List and filter tasks with advanced options
pub fn list_tasks(
    tags: &Option<String>,
    priority: &Option<CliPriority>,
    phase: &Option<String>,
    status: &Option<String>,
    search: &Option<String>,
    detailed: bool,
) -> CommandResult {
    let roadmap = state::load_state()?;

    // Start with all tasks
    let mut filtered_tasks: Vec<&Task> = roadmap.tasks.iter().collect();

    // Apply tag filter
    if let Some(tag_str) = tags {
        let filter_tags: Vec<String> = tag_str.split(',').map(|s| s.trim().to_string()).collect();
        filtered_tasks.retain(|task| filter_tags.iter().any(|tag| task.has_tag(tag)));
    }

    // Apply priority filter
    if let Some(ref priority_cli) = priority {
        let priority_model: Priority = priority_cli.clone().into();
        filtered_tasks.retain(|task| task.priority == priority_model);
    }

    // Apply phase filter
    if let Some(ref phase_str) = phase {
        let phase_model = Phase::from_string(phase_str);
        filtered_tasks.retain(|task| task.phase == phase_model);
    }

    // Apply status filter
    if let Some(ref status_str) = status {
        match status_str.to_lowercase().as_str() {
            "pending" => filtered_tasks.retain(|task| task.status == TaskStatus::Pending),
            "completed" => filtered_tasks.retain(|task| task.status == TaskStatus::Completed),
            "all" => {} // Keep all tasks
            _ => {
                return Err(format!(
                    "Invalid status filter: {}. Use 'pending', 'completed', or 'all'.",
                    status_str
                )
                .into())
            }
        }
    }

    // Apply search filter
    if let Some(ref query) = search {
        let search_results = roadmap.search_tasks(query);
        let search_ids: std::collections::HashSet<usize> =
            search_results.iter().map(|t| t.id).collect();
        filtered_tasks.retain(|task| search_ids.contains(&task.id));
    }

    // Display filtered results
    ui::display_filtered_tasks(&roadmap, &filtered_tasks, detailed);

    Ok(())
}

/// View detailed information about a specific task
pub fn view_task(task_id: usize) -> CommandResult {
    let roadmap = state::load_state()?;

    // Find the task
    let task = roadmap
        .find_task_by_id(task_id)
        .ok_or_else(|| format!("Task #{} not found", task_id))?;

    // Display detailed task information
    ui::display_detailed_task_view(task, &roadmap);

    Ok(())
}

/// Start time tracking for a task
pub fn start_time_tracking(task_id: usize, description: Option<&str>) -> CommandResult {
    let mut roadmap = state::load_state()?;

    // Check if any task already has an active time session
    for task in &roadmap.tasks {
        if task.has_active_time_session() {
            return Err(format!(
                "Task #{} already has an active time session. Stop it first with 'rask stop'",
                task.id
            )
            .into());
        }
    }

    // Find the task to start tracking
    let task = roadmap
        .find_task_by_id_mut(task_id)
        .ok_or_else(|| format!("Task #{} not found", task_id))?;

    // Get task description before borrowing mutably
    let task_description = task.description.clone();

    // Start time tracking
    match task.start_time_session(description.map(|s| s.to_string())) {
        Ok(()) => {
            // Save the updated state
            state::save_state(&roadmap)?;

            ui::display_info(&format!(
                "üïê Started time tracking for task #{}: {}",
                task_id, task_description
            ));
            if let Some(desc) = description {
                ui::display_info(&format!("üìù Session description: {}", desc));
            }
            ui::display_info("üí° Use 'rask stop' to end this session");
            Ok(())
        }
        Err(e) => Err(e.into()),
    }
}

/// Stop time tracking for the currently active task
pub fn stop_time_tracking() -> CommandResult {
    let mut roadmap = state::load_state()?;

    // Find the task with active time session
    let mut active_task_id = None;
    for task in &roadmap.tasks {
        if task.has_active_time_session() {
            active_task_id = Some(task.id);
            break;
        }
    }

    let task_id = active_task_id.ok_or("No active time tracking session found")?;

    // Stop time tracking
    let task = roadmap
        .find_task_by_id_mut(task_id)
        .ok_or("Task with active time session not found - data may be corrupted")?;
    let task_description = task.description.clone();

    match task.end_current_time_session() {
        Ok(duration_hours) => {
            let estimated_hours = task.estimated_hours;
            let total_tracked = task.get_total_tracked_hours();

            // Save the updated state
            state::save_state(&roadmap)?;

            ui::display_info(&format!(
                "‚è±Ô∏è  Stopped time tracking for task #{}: {}",
                task_id, task_description
            ));
            ui::display_info(&format!("‚è∞ Session duration: {:.2} hours", duration_hours));

            // Show updated totals
            if let Some(estimated) = estimated_hours {
                let variance = total_tracked - estimated;
                let percentage = (variance / estimated) * 100.0;

                ui::display_info(&format!(
                    "üìä Total tracked: {:.2}h | Estimated: {:.2}h | Variance: {:.2}h ({:+.1}%)",
                    total_tracked, estimated, variance, percentage
                ));
            } else {
                ui::display_info(&format!(
                    "üìä Total tracked time: {:.2} hours",
                    total_tracked
                ));
            }

            Ok(())
        }
        Err(e) => Err(e.into()),
    }
}

/// Show time tracking information
pub fn show_time_tracking(
    task_id: &Option<usize>,
    summary: bool,
    _detailed: bool,
) -> CommandResult {
    let roadmap = state::load_state()?;

    if let Some(id) = task_id {
        // Show time info for specific task
        let task = roadmap
            .find_task_by_id(*id)
            .ok_or_else(|| format!("Task #{} not found", id))?;

        // TODO: Implement proper time info display
        ui::display_info(&format!(
            "‚è∞ Time tracking for task #{}: {}",
            id, task.description
        ));

        if let Some(est) = task.estimated_hours {
            ui::display_info(&format!("üìä Estimated: {:.2} hours", est));
        }

        if let Some(actual) = task.actual_hours {
            ui::display_info(&format!("üìä Actual: {:.2} hours", actual));
        }

        if task.has_active_time_session() {
            ui::display_info("üïê Active time session running");
        }

        ui::display_info(&format!("üìà Total sessions: {}", task.time_sessions.len()));
    } else if summary {
        // Show summary across all tasks
        let total_estimated: f64 = roadmap.tasks.iter().filter_map(|t| t.estimated_hours).sum();
        let total_actual: f64 = roadmap.tasks.iter().filter_map(|t| t.actual_hours).sum();
        let tasks_with_estimates = roadmap
            .tasks
            .iter()
            .filter(|t| t.estimated_hours.is_some())
            .count();
        let tasks_with_time = roadmap
            .tasks
            .iter()
            .filter(|t| t.actual_hours.is_some())
            .count();

        ui::display_info("üìä Time Tracking Summary");
        ui::display_info(&format!(
            "Total estimated time: {:.2} hours ({} tasks)",
            total_estimated, tasks_with_estimates
        ));
        ui::display_info(&format!(
            "Total tracked time: {:.2} hours ({} tasks)",
            total_actual, tasks_with_time
        ));

        if total_estimated > 0.0 {
            let variance = total_actual - total_estimated;
            let percentage = (variance / total_estimated) * 100.0;
            ui::display_info(&format!(
                "Variance: {:.2} hours ({:+.1}%)",
                variance, percentage
            ));
        }
    } else {
        // Show time info for all tasks with time data
        ui::display_info("üìä Time Tracking Overview");
        for task in &roadmap.tasks {
            if task.estimated_hours.is_some()
                || task.actual_hours.is_some()
                || !task.time_sessions.is_empty()
            {
                let est = task
                    .estimated_hours
                    .map_or("--".to_string(), |h| format!("{:.2}h", h));
                let actual = task
                    .actual_hours
                    .map_or("--".to_string(), |h| format!("{:.2}h", h));
                let status = if task.has_active_time_session() {
                    "üïê"
                } else {
                    "  "
                };

                ui::display_info(&format!(
                    "{} #{}: {} | Est: {} | Actual: {}",
                    status, task.id, task.description, est, actual
                ));
            }
        }
    }

    Ok(())
}

/// Synchronize changes between roadmap files and Rask state
pub fn sync_project_files(
    from_roadmap: bool,
    from_details: bool,
    from_global: bool,
    to_files: bool,
    force: bool,
    dry_run: bool,
) -> CommandResult {
    // Global project management has been removed in favor of local-only approach
    if from_global {
        ui::display_warning("Global project management is no longer supported. Use local .rask/ directories instead.");
        ui::display_info("Initialize a local project with: rask init <roadmap.md>");
        return Ok(());
    }

    // Handle regenerating local files
    if to_files {
        return sync_to_local_files(force, dry_run);
    }

    // If no specific sync direction is specified, do a smart sync
    if !from_roadmap && !from_details {
        return smart_sync(force, dry_run);
    }

    if from_roadmap {
        sync_from_roadmap(force, dry_run)?;
    }

    if from_details {
        sync_from_task_details(force, dry_run)?;
    }

    Ok(())
}

/// Smart sync that detects which files have changed and syncs accordingly
fn smart_sync(force: bool, dry_run: bool) -> CommandResult {
    use crate::ui;

    ui::display_info("üîÑ Performing smart sync - detecting changes...");

    let rask_dir = Path::new(".rask");
    if !rask_dir.exists() {
        return Err(
            "No .rask directory found. Initialize a project first with 'rask init'.".into(),
        );
    }

    // Check if we have a roadmap state to compare against
    let roadmap = match state::load_state() {
        Ok(roadmap) => roadmap,
        Err(_) => {
            ui::display_warning("No project state found. Please run 'rask init' first.");
            return Ok(());
        }
    };

    let mut sync_actions = Vec::new();

    // Check original roadmap file timestamp
    if let Some(ref source_file) = roadmap.source_file {
        let source_path = Path::new(source_file);
        if source_path.exists() {
            let last_sync_file = rask_dir.join("state/last_sync");

            if should_sync_file(&source_path, &last_sync_file) {
                sync_actions.push("roadmap");
                ui::display_info(&format!("üìù {} has newer changes", source_file));
            }
        }
    }

    // Check task details file timestamp
    let task_details_file = rask_dir.join("task-details.md");
    if task_details_file.exists() {
        let last_sync_file = rask_dir.join("state/last_sync");

        if should_sync_file(&task_details_file, &last_sync_file) {
            sync_actions.push("task-details");
            ui::display_info("üìä task-details.md has newer changes");
        }
    }

    if sync_actions.is_empty() {
        ui::display_success("‚úÖ All files are in sync!");
        return Ok(());
    }

    if dry_run {
        ui::display_info("üîç Dry run - would sync:");
        for action in &sync_actions {
            println!("   ‚Ä¢ {}", action);
        }
        return Ok(());
    }

    // Perform the sync operations
    for action in &sync_actions {
        match *action {
            "roadmap" => sync_from_roadmap(force, false)?,
            "task-details" => sync_from_task_details(force, false)?,
            _ => {}
        }
    }

    // Update last sync timestamp
    update_last_sync_timestamp()?;

    ui::display_success(&format!(
        "‚úÖ Synced {} file(s) successfully!",
        sync_actions.len()
    ));
    Ok(())
}

/// Sync changes from the original roadmap file to Rask state
fn sync_from_roadmap(force: bool, dry_run: bool) -> CommandResult {
    use crate::{parser, ui};

    let roadmap = state::load_state()?;

    let source_file = roadmap
        .source_file
        .as_ref()
        .ok_or("No source roadmap file configured")?;

    let source_path = Path::new(source_file);
    if !source_path.exists() {
        return Err(format!("Source roadmap file not found: {}", source_file).into());
    }

    if dry_run {
        ui::display_info(&format!("üîç Dry run - would sync from {}", source_file));
        return Ok(());
    }

    ui::display_info(&format!("üìù Syncing from roadmap file: {}", source_file));

    // Create backup if not forcing
    if !force {
        create_backup(&roadmap)?;
    }

    // Parse the updated roadmap file
    let markdown_content = fs::read_to_string(source_path)?;
    let mut updated_roadmap =
        parser::parse_markdown_to_roadmap(&markdown_content, Some(source_path), &roadmap.title)?;

    // Preserve metadata and project ID
    updated_roadmap.metadata = roadmap.metadata;
    updated_roadmap.project_id = roadmap.project_id;

    // Save the updated state
    state::save_state(&updated_roadmap)?;

    // Regenerate project files
    let rask_dir = Path::new(".rask");
    create_project_overview(&updated_roadmap, &rask_dir)?;
    create_task_details_file(&updated_roadmap, &rask_dir)?;

    ui::display_success("‚úÖ Successfully synced from roadmap file!");
    Ok(())
}

/// Sync changes from task details file to Rask state
fn sync_from_task_details(_force: bool, dry_run: bool) -> CommandResult {
    use crate::ui;

    if dry_run {
        ui::display_info("üîç Dry run - would sync from task-details.md");
        return Ok(());
    }

    // For now, this is a placeholder - implementing full parsing of task-details.md
    // would require a more sophisticated parser
    ui::display_warning("üìä Task details sync is not yet fully implemented");
    ui::display_info("üí° For now, edit tasks using Rask commands or edit the main roadmap.md");
    ui::display_info("   This feature will be enhanced in future versions");

    Ok(())
}

/// Check if a file should be synced based on timestamps
fn should_sync_file(file_path: &Path, last_sync_file: &Path) -> bool {
    use std::time::SystemTime;

    let file_modified = match file_path.metadata().and_then(|m| m.modified()) {
        Ok(time) => time,
        Err(_) => return false,
    };

    let last_sync_time = match last_sync_file.metadata().and_then(|m| m.modified()) {
        Ok(time) => time,
        Err(_) => SystemTime::UNIX_EPOCH, // If no last sync file, consider everything newer
    };

    file_modified > last_sync_time
}

/// Create a backup of the current roadmap state
fn create_backup(roadmap: &crate::model::Roadmap) -> CommandResult {
    use chrono::Utc;

    let rask_dir = Path::new(".rask");
    let backup_dir = rask_dir.join("backups");

    if !backup_dir.exists() {
        fs::create_dir_all(&backup_dir)?;
    }

    let timestamp = Utc::now().format("%Y%m%d_%H%M%S").to_string();
    let backup_file = backup_dir.join(format!("backup_{}.json", timestamp));

    let json_data = serde_json::to_string_pretty(roadmap)?;
    fs::write(&backup_file, json_data)?;

    crate::ui::display_info(&format!("üíæ Created backup: {}", backup_file.display()));
    Ok(())
}

/// Update the last sync timestamp
fn update_last_sync_timestamp() -> CommandResult {
    let rask_dir = Path::new(".rask");
    let state_dir = rask_dir.join("state");

    if !state_dir.exists() {
        fs::create_dir_all(&state_dir)?;
    }

    let last_sync_file = state_dir.join("last_sync");
    fs::write(&last_sync_file, "")?; // Just touch the file to update timestamp

    Ok(())
}

/// Regenerate .rask project files from current state
fn sync_to_local_files(force: bool, dry_run: bool) -> CommandResult {
    use crate::{state, ui};

    if dry_run {
        ui::display_info("üîç Dry run - would regenerate .rask project files");
        return Ok(());
    }

    ui::display_info("üìÅ Regenerating .rask project files from current state...");

    // Load current state
    let roadmap = match state::load_state() {
        Ok(roadmap) => roadmap,
        Err(e) => {
            ui::display_error(&format!("‚ùå Cannot load project state: {}", e));
            return Err(e.into());
        }
    };

    let rask_dir = Path::new(".rask");

    // Create backup if not forcing
    if !force && rask_dir.exists() {
        create_backup(&roadmap)?;
    }

    // Ensure .rask directory exists
    if !rask_dir.exists() {
        fs::create_dir_all(rask_dir)?;
    }

    // Regenerate all project files
    create_project_overview(&roadmap, &rask_dir)?;
    create_task_details_file(&roadmap, &rask_dir)?;

    // Only recreate config and readme if they don't exist or force is true
    let config_file = rask_dir.join("config.toml");
    let readme_file = rask_dir.join("README.md");

    if !config_file.exists() || force {
        let source_path = roadmap
            .source_file
            .as_ref()
            .map(|s| Path::new(s))
            .unwrap_or_else(|| Path::new("roadmap.md"));
        create_project_config(&roadmap, &rask_dir, source_path)?;
    }

    if !readme_file.exists() || force {
        create_rask_readme(&rask_dir)?;
    }

    // Update last sync timestamp
    update_last_sync_timestamp()?;

    ui::display_success("‚úÖ Successfully regenerated .rask project files!");
    ui::display_info("üìä project-overview.md  - Updated project statistics");
    ui::display_info("üìù task-details.md      - Updated task metadata");

    Ok(())
}

/// üöÄ Quick task creation with natural language parsing
pub fn quick_add_task(text: &str) -> CommandResult {
    let parsed = parse_natural_language_task(text);

    // Show what was parsed for user feedback
    ui::display_info("ü§ñ Parsed task information:");
    ui::display_info(&format!("üìù Description: {}", parsed.description));
    ui::display_info(&format!(
        "üè∑Ô∏è  Tags: {}",
        if parsed.tags.is_empty() {
            "None".to_string()
        } else {
            parsed.tags.join(", ")
        }
    ));
    ui::display_info(&format!("‚ö° Priority: {}", parsed.priority));
    ui::display_info(&format!(
        "üöÄ Phase: {}",
        parsed.phase.as_ref().unwrap_or(&"mvp".to_string())
    ));

    // Convert to add_task_enhanced parameters
    let tags_str = if parsed.tags.is_empty() {
        None
    } else {
        Some(parsed.tags.join(","))
    };
    let priority = Some(parsed.priority.into());
    let phase = parsed.phase.clone();

    // Call the existing add_task_enhanced function
    add_task_enhanced(
        &parsed.description,
        &tags_str,
        &priority,
        &phase,
        &None, // notes
        &None, // dependencies
        &parsed.estimated_hours,
    )
}

/// Parse natural language text into task components
struct ParsedTask {
    description: String,
    tags: Vec<String>,
    priority: Priority,
    phase: Option<String>,
    estimated_hours: Option<f64>,
}

fn parse_natural_language_task(text: &str) -> ParsedTask {
    let mut description = text.to_string();
    let mut tags = Vec::new();
    let mut priority = Priority::Medium;
    let mut phase = None;
    let mut estimated_hours = None;

    // Priority keywords (case insensitive) - more specific patterns
    let priority_patterns = [
        ("critical", Priority::Critical),
        ("urgent", Priority::Critical),
        ("high priority", Priority::High),
        ("high", Priority::High),
        ("important", Priority::High),
        ("medium priority", Priority::Medium),
        ("medium", Priority::Medium),
        ("normal", Priority::Medium),
        ("low priority", Priority::Low),
        ("low", Priority::Low),
    ];

    // Phase keywords - more specific patterns
    let phase_patterns = [
        ("mvp", "mvp"),
        ("beta", "beta"),
        ("release", "release"),
        ("future", "future"),
        ("backlog", "backlog"),
        ("later", "future"),
        ("someday", "backlog"),
    ];

    // Common tag patterns - more specific to avoid false matches
    let tag_patterns = [
        ("backend", "backend"),
        ("frontend", "frontend"),
        ("front-end", "frontend"),
        ("api", "api"),
        ("ui", "ui"),
        ("ux", "ux"),
        ("database", "database"),
        ("db", "database"),
        ("auth", "auth"),
        ("authentication", "auth"),
        ("security", "security"),
        ("testing", "testing"),
        ("test", "testing"),
        ("bug", "bug"),
        ("fix", "bug"),
        ("feature", "feature"),
        ("deploy", "deployment"),
        ("deployment", "deployment"),
        ("production", "production"),
        ("staging", "staging"),
        ("docs", "documentation"),
        ("documentation", "documentation"),
        ("refactor", "refactoring"),
        ("performance", "performance"),
        ("optimization", "performance"),
        ("mobile", "mobile"),
        ("web", "web"),
        ("desktop", "desktop"),
        ("infrastructure", "infrastructure"),
    ];

    let text_lower = text.to_lowercase();
    let words: Vec<&str> = text_lower.split_whitespace().collect();

    // Track which standalone words/phrases we've extracted to remove them more precisely
    let mut standalone_words_to_remove: Vec<String> = Vec::new();

    // Extract priority - check longer phrases first, only if they are standalone
    for (keyword, prio) in &priority_patterns {
        // Check if the keyword appears as standalone words
        if keyword.contains(' ') {
            // Multi-word phrase - check if it appears exactly
            if text_lower.contains(keyword) {
                priority = prio.clone();
                standalone_words_to_remove.push(keyword.to_string());
                break;
            }
        } else {
            // Single word - check if it appears as a standalone word
            if words.iter().any(|&word| word == *keyword) {
                priority = prio.clone();
                standalone_words_to_remove.push(keyword.to_string());
                break;
            }
        }
    }

    // Extract phase - only if standalone words
    for (keyword, phase_val) in &phase_patterns {
        if words.iter().any(|&word| word == *keyword) {
            phase = Some(phase_val.to_string());
            standalone_words_to_remove.push(keyword.to_string());
            break;
        }
    }

    // Extract tags - be very careful about context, only exact word matches for short words
    for (keyword, tag) in &tag_patterns {
        if keyword.len() <= 3 {
            // Short words like "ui", "ux", "db" - must be exact standalone words
            if words.iter().any(|&word| word == *keyword) {
                tags.push(tag.to_string());
                standalone_words_to_remove.push(keyword.to_string());
            }
        } else {
            // Longer words - check if they appear as standalone words or as part of compound words
            if words
                .iter()
                .any(|&word| word == *keyword || word.contains(keyword))
            {
                tags.push(tag.to_string());
                // DON'T remove longer words from description to preserve meaning
                // Only remove if it's clearly a metadata word (like "backend", "frontend")
                if *keyword == "backend"
                    || *keyword == "frontend"
                    || *keyword == "testing"
                    || *keyword == "deployment"
                    || *keyword == "documentation"
                    || *keyword == "infrastructure"
                {
                    if words.iter().any(|&word| word == *keyword) {
                        standalone_words_to_remove.push(keyword.to_string());
                    }
                }
            }
        }
    }

    // Extract time estimates
    let time_keywords = [
        ("hours", 1.0, "h"),
        ("hour", 1.0, "h"),
        ("hrs", 1.0, "hr"),
        ("hr", 1.0, "hr"),
        ("days", 8.0, "day"),
        ("day", 8.0, "day"),
        ("weeks", 40.0, "week"),
        ("week", 40.0, "week"),
    ];

    // More precise time extraction
    for i in 0..words.len().saturating_sub(1) {
        if let Ok(time_val) = words[i].parse::<f64>() {
            for (keyword, multiplier, _short) in &time_keywords {
                if words[i + 1].starts_with(keyword) {
                    estimated_hours = Some(time_val * multiplier);
                    // Remove the time pattern more precisely
                    standalone_words_to_remove.push(format!("{} {}", words[i], words[i + 1]));
                    break;
                }
            }
            if estimated_hours.is_some() {
                break;
            }
        }
    }

    // Very careful removal of extracted keywords while preserving description integrity
    for word_to_remove in &standalone_words_to_remove {
        // Use word boundary regex to ensure we only remove complete words
        let regex_pattern = if word_to_remove.contains(' ') {
            // Multi-word phrase - match exactly with word boundaries
            format!(r"(?i)\b{}\b", regex::escape(word_to_remove))
        } else {
            // Single word - match with word boundaries
            format!(r"(?i)\b{}\b", regex::escape(word_to_remove))
        };

        if let Ok(re) = regex::Regex::new(&regex_pattern) {
            description = re.replace_all(&description, " ").to_string();
        }
    }

    // Clean up description (remove extra spaces, trim)
    description = description
        .split_whitespace()
        .collect::<Vec<&str>>()
        .join(" ")
        .trim()
        .to_string();

    // If description is empty or too short after cleaning, preserve more of the original
    if description.is_empty() || description.len() < 3 {
        // Keep the original but still extract metadata
        description = text.to_string();
    }

    // Remove duplicates from tags
    tags.sort();
    tags.dedup();

    ParsedTask {
        description,
        tags,
        priority,
        phase,
        estimated_hours,
    }
}

/// üéØ Show tasks ready to start (no blockers)
pub fn show_ready_tasks() -> CommandResult {
    let roadmap = state::load_state()?;
    let ready_tasks = roadmap.get_ready_tasks();

    if ready_tasks.is_empty() {
        ui::display_info("üéØ No ready tasks found");
        ui::display_info(
            "üí° All tasks either have incomplete dependencies or are already completed",
        );
    } else {
        ui::display_info(&format!(
            "üéØ Ready Tasks ({} available to start)",
            ready_tasks.len()
        ));
        ui::display_filtered_tasks(&roadmap, &ready_tasks, false);
    }

    Ok(())
}

/// üî• Show urgent tasks (high/critical priority)
pub fn show_urgent_tasks() -> CommandResult {
    let roadmap = state::load_state()?;
    let urgent_tasks: Vec<&Task> = roadmap
        .tasks
        .iter()
        .filter(|task| {
            matches!(task.priority, Priority::High | Priority::Critical)
                && task.status == TaskStatus::Pending
        })
        .collect();

    if urgent_tasks.is_empty() {
        ui::display_info("üî• No urgent tasks found");
        ui::display_info("üí° All high/critical priority tasks are completed or none exist");
    } else {
        ui::display_info(&format!(
            "üî• Urgent Tasks ({} high/critical priority)",
            urgent_tasks.len()
        ));
        ui::display_filtered_tasks(&roadmap, &urgent_tasks, false);
    }

    Ok(())
}

/// üîí Show blocked tasks (waiting on dependencies)
pub fn show_blocked_tasks() -> CommandResult {
    let roadmap = state::load_state()?;
    let blocked_tasks = roadmap.get_blocked_tasks();

    if blocked_tasks.is_empty() {
        ui::display_info("üîí No blocked tasks found");
        ui::display_info("üí° All tasks are either ready to start or completed");
    } else {
        ui::display_info(&format!(
            "üîí Blocked Tasks ({} waiting on dependencies)",
            blocked_tasks.len()
        ));
        ui::display_filtered_tasks(&roadmap, &blocked_tasks, true); // Show detailed for dependencies
    }

    Ok(())
}

/// üîç Enhanced search tasks by description, notes, and tags
pub fn find_tasks(query: &str) -> CommandResult {
    let roadmap = state::load_state()?;

    // Use the model's search_tasks method which includes tags, descriptions, and notes
    let found_tasks = roadmap.search_tasks(query);

    if found_tasks.is_empty() {
        ui::display_info(&format!("üîç No tasks found matching '{}'", query));
        ui::display_info("üí° Search includes task descriptions, notes, and tags");
        ui::display_info("üí° Try a different search term or check spelling");

        // Provide helpful suggestions
        let all_tags: std::collections::HashSet<String> = roadmap
            .tasks
            .iter()
            .flat_map(|t| &t.tags)
            .cloned()
            .collect();
        if !all_tags.is_empty() && all_tags.len() <= 10 {
            let tags_sample: Vec<_> = all_tags.iter().take(5).collect();
            ui::display_info(&format!(
                "üí° Available tags: {}",
                tags_sample
                    .iter()
                    .map(|t| format!("#{}", t))
                    .collect::<Vec<_>>()
                    .join(", ")
            ));
        }
    } else {
        // Show what was matched
        let mut tag_matches = 0;
        let mut description_matches = 0;
        let mut notes_matches = 0;

        let query_lower = query.to_lowercase();
        for task in &found_tasks {
            if task
                .tags
                .iter()
                .any(|tag| tag.to_lowercase().contains(&query_lower))
            {
                tag_matches += 1;
            }
            if task.description.to_lowercase().contains(&query_lower) {
                description_matches += 1;
            }
            if task
                .notes
                .as_ref()
                .map_or(false, |notes| notes.to_lowercase().contains(&query_lower))
            {
                notes_matches += 1;
            }
        }

        let mut match_info = Vec::new();
        if description_matches > 0 {
            match_info.push(format!("{} in descriptions", description_matches));
        }
        if tag_matches > 0 {
            match_info.push(format!("{} in tags", tag_matches));
        }
        if notes_matches > 0 {
            match_info.push(format!("{} in notes", notes_matches));
        }

        ui::display_info(&format!(
            "üîç Found {} task(s) matching '{}' ({})",
            found_tasks.len(),
            query,
            match_info.join(", ")
        ));
        ui::display_filtered_tasks(&roadmap, &found_tasks, false);
    }

    Ok(())
}
